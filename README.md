# java-racingcar-precourse
## 1급 개념
- **자동차**
- **경주**

## 기능 목록
- [x] 자동차 이름들을 입력 받는다
  - 시스템 예외: 입력이 `null`, `EOF`를 찾을 수 없는 경우
  - 사용자 예외: 입력이 빈 문자열인 경우
  - 사용자 예외: 공백을 포함한 경우
  - 사용자 예외: 한글, 숫자, 알파벳 대소문자, 언더바(`_`), 쉼표(`,`)외 문자를 포함한 경우
- [x] 시도할 횟수를 입력 받는다
  - 시스템 예외: 입력이 `null`, `EOF`를 찾을 수 없는 경우
  - 사용자 예외: 입력이 빈 문자열인 경우
  - 사용자 예외: 공백을 포함한 경우
  - 사용자 예외: 숫자가 아닌 문자를 입력한 경우
  - 쉼표(`,`)로 구분한다
  - 사용자 예외: 구분한 문자열이 공백(빈 문자열)인 경우
- [x] 자동차 경주 시작을 요청한다
  - 자동차 이름을 쉼표로 구분
  - 시스템 예외: 구분한 이름값들이 `null`인 경우
  - 사용자 예외: 이름 입력을 구분한 문자열이 공백(빈 문자열)인 경우
  - 사용자 예외: 라운드 입력이 정수가 아닌 경우
- [x] 자동차 경주를 시작한다
  - 값을 가져와 도메인에 전달하는 것은 서비스의 역할
  - 자동차 경주는 1 ~ 100 라운드 진행 가능
- [x] 자동차를 생성한다
  - 시스템 예외: 이름이 `null`인 경우
  - 사용자 예외: 이름이 범위(1 ~ 5)를 벗어난 경우
  - 사용자 예외: 이름 패턴을 벗어난 경우
    - 알파벳(대소문자), 한글, 숫자, 언더바 `_`만 허용
- [x] 자동차들을 생성한다
  - 시스템 예외: 자동차들이 `null`인 경우
  - 사용자 예외: 이름이 존재하지 않는 경우 
  - 사용자 예외: 중복 이름이 존재하는 경우
- [x] 자동차를 움직인다
  - 랜덤값이 4 이상인 경우 전진한다
  - 랜덤값이 4 미만인 경우 멈춘다
- [x] 랜덤값을 생성한다
  - 시스템 예외: 랜덤값들이 `null`인 경우 
  - 값은 제어와 통제가 불가능 -> 외부 API
  - 값의 범위는 완벽한 제어와 통제가 가능 -> 도메인 규칙
- [x] 라운드 결과를 저장한다
- [x] 최종 우승자를 선정한다
  - 시스템 예외: 최종 우승자 이름들이 `null`인 경우 
  - 우승자는 1명 이상이다
- [x] 실행 결과를 출력한다
  - 시스템 예외: 자동차 경주 응답이 `null`인 경우
  - 라운드마다 이름 : 위치(-) 출력
  - 최종 우승자 : 이름...

## 명시되지 않은 요구사항 추가 근거
- 이름에 알파벳(대소문자), 한글, 숫자, 언더바 `_`만 허용
  - SQL Injection, XSS 같은 보안 관련 공격 예방
  - 알파벳(대소문자): 시스템 호환성, 대부분의 API, DB 등은 통신을 위해 국제 표준(ASCII)을 따름
  - 한글: 서비스가 주로 제공되는 지역 고려
  - 언더바`_`: URL 친화적, 검색 엔진이 `_`를 구분자로 인식, DB 친화적, 공백을 대체하는 구분자

## 판단 근거
- 이름 입력 순으로 출력하기 위해 FIFO 구조가 좋아 보이는데 왜 `List(ArrayList)` 사용?
  - `List`는 순서가 보장된 자료구조
  - JDK21 부터 `List`는 `SequencedCollection` 하위 -> 관련 메서드 사용 가능, 명시적인 순서 보장 컬렉션
- cars 일급 컬렉션에 왜 `LinkedHashSet`을 사용하지 않고 `List(ArrayList)`?
  - `LinkedHashSet`은 `SequencedCollection` -> 고유성, 순서 보장이 되지만 조회가 불가능
  - `Map<Name, Car>` 형태는? `Name` 중복, 이를 해결하려면 자동차에 `Position`만 존재 -> 이름은 자동차의 상태
- 일급 컬렉션에서 조회를 위해 컬렉션을 반환할 때 어떻게 처리?
  - `Cars`: `Car`의 `Name`은 불변 객체라 원본에 영향을 줄 수 없다. 하지만 `Position`은 가변 객체 -> 원본과 참조를 끊는 `Car` 복사본이 필요
  - `Results`: 모두 불변 객체라 `toList()`를 통해
- 인스턴스화를 위한 검증은 생성자의 역할인가 정적 팩토리 메서드의 역할인가
  - 생성자의 역할이라 판단: 정적 팩토리 메서드는 공장, 생성자는 공장 내부에서 실제로 생성하는 생산 라인
  - 공장이 아닌 생산 라인에서 검증해야 한다
  - 복잡한 객체 생성 로직이나 캐싱이 필요한 경우 정적 팩토리 메서드 에서 진행 -> `LocalDate.of()`를 봐보자
- 메서드 순서 통일
  - 상수 -> 변수 -> 생성자 -> 정적 팩토리 메서드 -> public 메서드 -> private 메서드 -> getter -> equals & hashCode & toString
- 시스템 예외가(`null` 발생) 발생할 수 있는 상황
  - 계층 간 데이터를 전달할 때 발생할 확률이 높음
  - 계층 간 데이터를 전달하기 전 송신자 측에서 검사한다
