# 📌 Gradle
- `id 'org.gradle.toolchains.foojay-resolver-convention' version '0.8.0'` ?
    - Foojay Disco API를 사용해 Java 런타임을 해결하는 resolver, 툴체인 관리를 자동으로 구성
    - Foojay Disco API: 다양한 배포에서 JDK 빌드를 검색하는 범용 API
    - JVM을 다운로드하기 위한 저장소를 제공, 프로젝트의 Java 버전 관리를 간소화 시켜줌
    - 필요한 JDK를 자동으로 다운로드(local에 JDK가 설치되어 있다면 local JDK 우선 사용)
    - `$./gradlew javaToolchains`로 설치된 툴체인 정보 확인 가능: 로컬과 IDE에 설치되어 있는 Java 버전과 위치, 벤더 등의 정보를 알 수 있고 현재 사용중인 JDK를 알려줌

    ```groovy
    java {
        toolchain { // Java 버전을 21로 지정, 벤더는 따로 강제하지 않음
            languageVersion = JavaLanguageVersion.of(21)
        }
    }
    ```
- `gradle/`은 git로 관리하고 `.gradle/`은 왜 관리하지 않을까?
    - `.gradle`: Gradle의 캐시 및 설정 파일을 포함, 로컬 환경에 종속적인 데이터들이 저장되어 공유할 필요가 없음
    - `gradle/wrapper/gradle-wrapper.jar`:Gradle의 wrapper 실행 파일로, 프로젝트에서 특정 Gradle 버전을 사용할 수 있게 해주는 자바 실행 파일, 프로젝트의 일관성을 위해 공유대상에 포함
- `$gradlew`, `$gradlew.bat`이 정확히 어디에 쓰일까?
    - gradlew: Unix/Linux/Mac 에서 사용하는 Gradle Wrapper와 관련된 스크립트 파일
    - gradlew.bat: Windows 에서 사용하는 Gradle Wrapper와 관련된 스크립트 파일
    - 프로젝트를 받은 개발자의 환경을 모두 고려하기 위해 두 개의 파일을 관리, 프로젝트가 실행될 Gradle 버전을 고정해 빌드 환경 차이로 발생하는 문제를 방지
    - 별도의 gradle 설치를 로컬에서 진행하지 않아도 `$gradlew` 명령어로 지정된 버전이 다운로드 및 실행됨
- `$./gradlew clean test`를 실행하면 어떤 과정이 일어날까?
    - gradle wrapper 실행해 Gradle이 설치되어 있는지 확인하고, 없다면 설치
    - clean: 이전 빌드에서 생성된 파일(.class, .jar. build/ )을 삭제하고 새로운 빌드를 위한 상태를 준비
    - test: 프로젝트 내 테스트 코드를 실행, src/test/** 밑의 파일을 모두 실행, 결과는 build/reports/tests/ 밑에 HTML 형식의 보고서로 생성
    - 모든 테스트가 실행 된 후 완료되면 성공 여부, 결과, 통과한 테스트 수, 실패한 테스트 수 등의 정보가 생성됨. 만약 일부 테스트가 실패하거나 오류가 발생하면 에러 메시지와 함께 종료되며 어떤 테스트에서 문제가 발생했는지 알려줌

# 📌 기본적인 Git 명령어
- 어디까지가 기본적인 Git 명령어 일까?
    - 시작 단계: init, clone, branch, checkout
    - 시작 단계로 불러 왔으면: status, diff, log
    - 시작 환경을 설정하고 다음은 구현: add, commit
    - 구현을 하고 협업을 위해서는: push, merge, remote, fetch, pull
    - 실수를 잡기 위해서는: reset, checkout, revert
    - 기본에서 조금 더 나아가려면: rebase, stash, cherry-pick, tag

# 📌 .gitignore로 관리할 자원을 고려한다
- git에 올리지 않아도 되는 파일들은 개발 환경에서 생기는 부수적인 결과물(로컬 환경 설정로 생기는, 빌드 과정에서 자동 생성되는, IDE나 OS에 종속적인, 용량이 큰 빌드 결과물이나 캐시 파일, 소스 코드로 생성 가능한 파일들)
- `.class` 파일은 왜 관리할 필요가 없을까?
    - 빌드의 결과물, `.java`파일(소스 코드 디렉토리, 일반적으로 `**/src/main/**`, `**/src/test/**`) 이 있으면 생성 가능
- `.idea`, `.metadata`, `.DS_Store`, IDEA 관련 파일 등 기본적으로 명시된 자원에 대해 알고있나?
    - `.idea`: 인텔리제이 프로젝트 설정 디렉토리, IDE 특정 설정을 공유할 필요는 없음
    - `.iws`: 인텔리제이 워크스페이스 설정 파일, `.iml`: 인텔리제이에서 프로젝트를 위한 모듈 파일, `.ipr`: 인텔리제이에서 관리하는 프로젝트 파일, 개발자마다 인텔리제이에 올린 프로젝트가 다름
    - `.metadata`: IDE에서 생성하는 워크스페이스 관련 파일, 개발자마다 설정, 캐시, 로그 등이 다름
    - `.DS_Store`: Mac OS 디렉토리 설정 파일, 운영체제 관련 특정 파일
- `STS`, `NetBeans`?
    - STS: 스프링 프로젝트를 생성하고, 개발할 수 있게 해주는 도구로 개발자마다 프로젝트 생성 방법이 다름(spring initializr, IDE 플러그인 등)
    - NetBeans: IDE 중 하나, NetBeans IDE에 종속적인 파일들은 관리 대상이 아님
- 왜 관리 대상인지, 관리 대상이 아닌지 설명할 수 있나?
    - .classPath: Eclipse IDE 사용 시 클래스 경로 설정 파일로 사용, 환경에 따라 다르므로 공유할 필요가 없음
    - .apt_generated, .factorypath, .project, .settings 등: Eclipse/NetBeans/STS의 IDE에 종속적인 파일들

# 📌 의미 있는 커밋 메시지란?
- 커밋 메시지를 의미 있게 작성하라는데 의미가 있다는 것이 정확히 무엇일까?
    - 의미 있다 == 변경 사항이 명확하고 구체적으로 나타나야 한다
    - 변경 내용을 설명 + 목적을 설명 + 짧고 간결하게 + 일관성
- 커밋 메시지 컨벤션을 따른다고 무조건 의미가 있나?
    - 컨벤션(방법)은 목적을 효과적으로 이루기 위한 수단
    - 오랜 기간 많은 개발자들이 고민하고 만든 컨벤션을 따르면 일관되고 의미 있는 메시지를 빠르게 만들 수 있음
    - 컨벤션을 따르나 컨벤션에 목맬 필요가 없다
    - 중요한 것은 일관된 방법으로 변경 사항이 명확하게 드러나고, 커밋의 목적이 무엇인지, 짧고 간결하게 보여주는 것
- 좋은 커밋 메시지의 특징은?
  - 제목과 본문을 한 줄 띄워 분리: `$git log` 가독성 올리기
  - 제목은 명령조로
    - BAD: 인증 메서드를 고쳤다
    - GOOD: 인증 메서드 수정
  - 본문은 무엇을(What), 왜(How)
  - 커밋 로그도 문서처럼

# 📌IntelliJ IDEA Debugger
- 디버깅의 목적은?
    - 빠르고 정확한 문제 해결
    - 실행 흐름을 자세히 파악하고 원하는 흐름대로 진행되고 있는지 확인 -> 기대한 협력이 일어나고 있는지 눈으로 직접 볼 수 있음
    - 예상한(의도) 동작과 다른 동작인데 목표한 기대 결과가 나오는 경우가 있음
        - 예상한 동작: A -> B -> C(기대 결과)
        - 실제 동작: A -> D -> Z -> C(기대 결과)
- 왜 디버깅이 갈수록 중요해질까?
    - 현대 소프트웨어는 매우 복잡함 -> 다양한 컴포넌트, 모듈 간의 상호작용이 일어남
- 디버거를 사용하려면 toString() 재정의는 필수

# 📌 의도를 드러내는 네이밍
- 불용어?
    - a(n), the, i, my, me 등 자주 등장 하지만 실제 의미 분석을 하는데는 큰 기여를 하지 않는 단어들
- 축약하지 않는다, 의도를 드러낼 수 있다면 어디까지 길어져도 괜찮나?
    - 의도를 명확히 표현할 수 있다면 길어도 괜찮음
    - 길게 작성하고 리팩토링: 중복되는 단어, 불용어 등 작성 후 의미 분석에 큰 도움이 안되는 부분을 제거
- 의도를 드러냈다는 것은? 도메인을 알고 있는 사람과 모르는 사람이 모두 이해할 수 있는?
- 객체 지향 생활 체조 원칙?

# 📌 Java API
- 내부 라이브러리 활용, 기능을 만드는데 알고리즘 문제를 풀듯이 한다면 무언가 내부에서 제공하는 기능이 있지 않을까 의심하기
    - 보통 내가 구현하고 있는 알고리즘, 기능(변환, 검증, 확인 등)은 대부분의 개발자들도 과거 부터 고민한 부분, 이를 해결하기 위해 언어에서 만들어 제공하는 경우가 많음
- 왜 배열을 대신 컬렉션을 쓸까?
    - 동적인 크기 관리(배열은 고정 크기, 컬렉션은 동적으로 크기를 조절해 메모리를 효율적으로 사용)
        - 보통 컬렉션은 기본 크기가 지정되어 있고, 지정한 기본 크기의 75% 가량이 채워지면 크기를 늘려나감
    - 타입 안정성(배열은 런타임에 타입을 체크, 컬렉션은 컴파일 시점에 진행)
    - 다양한 메서드 제공(배열은 기본적인 CRUD만 제공, 컬렉션은 다양한 메서드 제공) -> 컬렉션은 데이터 조작이 간편함
    - 제네릭 지원(배열은 제네릭 사용 불가, 컬렉션은 제네릭을 완벽하게 지원)
    - Stream 활용이 편함(배열은 스트림으로 변환해야 하는 과정이 필요, 컬렉션은 즉시 사용 가능): Arrays.stream(배열) vs 컬렉션.stream()
- 컬렉션은 무조건 좋은가?
    - 크기가 고정된 경우, 성능이 매우 중요한 경우(하지만 현대 컴퓨터 뛰어난 성능으로 극단적인 경우를 제외하고 컬렉션을 사용해도 별 차이 없음)
- `var`를 언제 사용해도 좋을까?
- 왜 AssertJ를 많이 사용할까?

# 📌 문자열 덧셈 계산기 피드백

- 어디서부터 시작? 서로 생각이 다른데 어떻게 시작?
- 처음 시작 목표는 주어진 요구사항을 만족하는 것
    - 디테일한 사항 + 개인 판단은 뒤로 미루고
- 주어진 시간이 짧으면 명시된 요구사항을 먼저 처리하는 것을 고려 -> 돌아가는 쓰레기 먼저
    - 현재 역량이 낮다면 꼭 TDD에 집착할 필요가 없음, 먼저 프로덕션 코드를 만들고 테스트를 작성해도 괜찮
    - 내 역량에 맞게, 다만 주어진 시간이 넉넉하다면 TDD 사이클을 시도(컴포트 존 벗어나기)
- (구현 -> 구체화) 사이클
    - 숲을 만들려면 나무를 하나씩 심고 새로 심을 나무를 고려하고, 심을 곳을 조율
    - 나무를 먼저 어디에 어떻게 심는지 세세하게 고려해 시작하면 문제 발생 시 해결 어려움
- 상수로 빼는 이유는 무엇인가?
    - 굳이 분리해야 의미가 드러나는 부분인가 고민
    ```java
    // 상수로 분리한다고 무조건 좋을까?
    private static final String INPUT_DELIMITER = ",";
    String text = "1,2,3";
        
    text.split(INPUT_DELIMITER);
    text.split(","); // 콤마로 구분한다는 것을 알 수 있는데 굳이 상수로?
    ```
    - 구현을 하다 불편(무슨 의미인지 모르겠으면), 이런 시점이 왔을 때 판단
    - 내 생각은 매직넘버, 문자열이 존재한다고 무조건 상수 분리를 하는게 좋은 판단은 아니라고 생각함
- `assertThrows` vs `assertThatThrownBy`
- 1 순위는 주어진(명시된) 요구사항 처리
