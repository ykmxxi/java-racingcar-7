# 개념과 격벽
> - **개념: 자동차 경주 프로그램을 지탱하는 것들**
> - **외부 라이브러리(Console, Random): 개념이라 보기 어려움**

- 자동차: 1급 개념
  - 이름: 상태, 2급 개념
    - 식별자 역할, 즉 고유한 값이어야 함
  - 위치: 상태, 2급 개념
    - 핵심 개념 경주에 영향을 주는 상태 값
  - 움직임(전진 or 멈춤): 행위, 위치(상태)에 영향
- 경주: 1급 개념
  - 라운드(시도 횟수): 상태, 2급 개념
  - 결과: 상태, 2급 개념
  - 랜덤값의 범위: 상수 -> 완벽하게 제어/통제 가능
  - 경주 진행: 행위, 자동차들에 움직임 요청해 차수 결과(상태)에 영향
- 자동차 경주(서비스): 2급 개념
  - 자동차와 경주의 비즈니스 흐름을 보여줌
- 클라이언트: 3급 개념
  - 화면과 서비스 사이에서 서비스 시작 요청을 전달하고, 서비스 결과 응답을 받아 전달한다
- 결과 화면: 3급 개념
  - 결과 출력 형식을 지키지 않으면 실패
- 입력 화면: 3급 개념
  - 완벽하게 제어하고 통제할 수 있는 요소: 자원 해제, 기본 입력 형식(null, empty, blank)
  - `ApplicationTest`에서 자원 해제를 진행, 하지만 프로덕션에서 자원 해제가 필요 -> 자원 해제가 없어도 테스트에서 문제가 없지만 운영 단계에서 문제 발생
- 입력, 랜덤값: 개념 X
  - 외부 라이브러리 `Console` 사용 -> 완벽한 제어/통제 불가능
  - 외부 라이브러리 `Randoms` 사용 -> 완벽한 제어/통제 불가능

<img width="800" alt="image" src="./images/concept-bulkhead.png">

# 기능 요구 사항 분석
- 주어진 횟수 동안 n대의 자동차는 전진 또는 멈출 수 있다.
  - 자동차는 스스로 움직임(전진/멈춤)
  - 자동차들에게 움직임(전진/멈춤)을 명령한다 -> 핵심 개념
- 각 자동차에 이름을 부여할 수 있다. 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.
  - 순서를 보장해야 한다
  - 자동차 경주 -> 보통의 경주는 정해진 레인에서 시작, 입력 순서대로 레인을 배정해 진행하는 것으로 설정
  - JDK 21 Sequenced Collection: List, LinkedHashMap 등 -> 최종 결과를 `getLast()`로 편리하게 볼 수 있음
- 자동차 이름은 쉼표(,)를 기준으로 구분하며 이름은 5자 이하만 가능하다.
  - 쉼표를 기준으로 구분하는 것은 Presentation Layer 책임
  - 이름이 5자 이하인지 검증하는것은 이름과 관련된 도메인의 책임
  - 이름에 공백을 포함? 이름에 이모지를 포함? -> 일종의 게임 닉네임, 보통 허용하지 않음
  - 여러 서비스(인스타, 배민 등)이름(닉네임)을 보면 영어(대소문자 구분), 숫자, `_`, 한글만 허용하는 곳이 많음
  - 아스키 코드 표준을 따름 -> 데이터 저장(DB)과의 연관성
- 사용자는 몇 번의 이동을 할 것인지를 입력할 수 있어야 한다.
  - 너무 많은 자동차와 너무 많은 횟수 -> 몇 개 까지 제한하고, 몇 번 까지 제한할까?
  - 자동차 수는 일단 제한하지 않음
  - 경주 횟수는 100번 제한: 사용자 디스플레이에 따라 다르나, 현재 출력 형식은 100번 가량 진행하는 것이 보기 편함
  - `Randoms`는 Integer.MAX_VALUE - 1 까지 지원하는데, 성능 향상? `ThreadPool` 관리와 `ExecutorService` 사용? 경주 알고리즘 성능 개선?
  - 현재 미션에 중요한 요소(목표)가 아님, 구현과 객체지향 설계가 목표, 시간이 매우 많이 남는다면 시도해볼만한 사항
- 전진하는 조건은 0에서 9 사이에서 무작위 값을 구한 후 무작위 값이 4 이상일 경우이다.
  - 무작위 값은 외부 API(`Randoms.pickNumberInRange()`) 호출 -> 내가 제어/통제할 수 없는 요소
  - 내가 제어/통제할 수 있는 부분은 4 이상일 경우를 판단하는 부분
- 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한 명 이상일 수 있다.
- 우승자가 여러 명일 경우 쉼표(,)를 이용하여 구분한다.
- 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException을 발생시킨 후 애플리케이션은 종료되어야 한다.
  - `IllegalArgumentException`: 부적절한 인수가 전달, 부적절한 인수를 누가 만들었나(누구의 책임: 사용자 or 개발자)?
    - 사용자: 빈 문자열, 공백으로 이루어진 문자열, 5자 초과
    - 개발자: null(변수 선언만 해놓고 넘어가는 경우, 실수로 놓칠 수 있음), 인수 타입에 맞지 않는 데이터 전달(컴파일 시점에 막을 수 있음) 
- 입력: 경주할 자동차 이름(이름은 쉼표(,) 기준으로 구분), 시도할 횟수
  - 이름을 쉼표 기준으로 구분한다는 것을 입력에서 알려주고 있음 -> 도메인 규칙이라 보기 애매함
  - 쉼표를 기준으로 구분해 넘겨주는 것은 입력, 즉 Presentation Layer 책임으로 도메인에서 진행할 필요가 없음
- 출력: 차수별 실행 결과, 우승자 안내 문구(단독 or 공동)
    - `String.join()` 활용
    - 차수별 실행 결과를 출력할 때, 차수별 결과를 바로 넘겨 출력 or 모든 차수가 끝난 후 결과를 넘겨 출력
    - 일반적인 애플리케이션은 어떻게 할까? 후자를 선택하면 DB 처럼 사용하는 저장소가 필요함
```text
경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)
pobi,woni,jun
시도할 횟수는 몇 회인가요?
5

실행 결과
pobi : -
woni : 
jun : -

pobi : --
woni : -
jun : --

pobi : ---
woni : --
jun : ---

pobi : ----
woni : ---
jun : ----

pobi : -----
woni : ----
jun : -----

최종 우승자 : pobi, jun
```

# 프로그래밍 요구 사항 분석
- 프로그램 실행의 시작점이 `Application.main()`이어야 하는 이유
  - `ApplicationTest.runMain()`이 호출, 즉 다른 곳에서 시작하면 ApplicationTest 무조건 실패
  - 그래서 명시하지 않은 파일, 패키지 이름을 변경하면 안됨
  - 시작점의 책임은? Java 프로그램이 시작하려면 어떤 것들이 필요한가?
  - System.exit() 호출하지 않는 이유는 [문자열 덧셈기 문서](https://github.com/ykmxxi/java-calculator-7/blob/ykmxxi/docs/concept_bulkhead.md)
- indent depth 3이 넘지 않도록 구현한다, 2까지만 허용, 왜 indent depth를 2로 제한할까?
  - 함수가 한 가지 일만 하도록 최대한 작게 만들 수 있는 제한 사항
  - 가독성이 떨어짐: for 내부의 if 내부의 if, 이런 식으로 중첩될 수록 읽기 힘들어짐
  - 마치 만약에 A라면 어때? -> A인데 B를 더하면 어때? -> B를 더했는데 C가 아니면 어때? ... 꼬리물기 식으로 말하는것과 같음
  - 단일 책임 원칙으로 가는 필요 조건
- 왜 3항 연산자를 쓰지 않을까?
  - if or else: 흑백논리처럼 두 가지 상황으로만 치부함 -> 확장에 열려 있지 않는 코드를 만드는것 같음
  - age > 19 ? 성인 : 미성년자 -> 더 세부적으로 쪼개는 상황이 필요 -> `age > 19 ? ((age < 30) ? 20대 : (age ? 40) ?)...` 처럼 복잡해짐
  - 결국 if (early return) 패턴이 확장에 더 열려 있음
- 함수(또는 메서드)가 한 가지 일만 한도록 최대한 작게 만든다
  - 한 가지 일만 하는 것은 동의, 그런데 한 가지 일이라는 것이 정확히 무엇인가?
    - 메서드: 한 상태에만 영향을 준다
  - 어디까지를 한 가지 일이라고 볼 것인가?
    - 자동차의 `move()`는 위치에만 영향을 줘야 한다
  - 최대한 작게, 어디까지 작게 만들어야 할까?
    - private 메서드는 한 상태에 영향을 주는 메서드가 여러 문맥으로 이뤄져 있다면 분리한다. 즉, 한 상태를 변하게 만드는 행동에 포함되는 작은 행동들
- 왜 AssertJ를 많이 활용할까?
  - 더 직관적임 == 더 읽기 편함
    - `assertEquals(result, "result")` vs `assertThat(result).isEqualTo("result")`
    - `assertTrue(list.size() > 2)` vs `assertThat(list).hasSize(2)`
  - 편리한 기능을 더 많이 제공(더 다양한 검증 메서드를 제공)
  - 실패 시 이유가 더 자세함
  - 타입 안전성이 높음

  ```text
  JUnit Jupiter에서 제공하는 Assertions 기능만으로도 많은 테스트 시나리오에 충분하지만,
  더 강력한 성능과 매처와 같은 추가 기능이 필요하거나 필요한 경우가 있습니다.
  이러한 경우 JUnit 팀은 AssertJ, Hamcrest, Truth 등과 같은 타사 어설션 라이브러리를 사용할 것을 권장합니다.
  따라서 개발자는 원하는 Assertions 라이브러리를 자유롭게 사용할 수 있습니다.
  - JUnit5 Doc
  ```
- Randoms.pickNumberInRange()
